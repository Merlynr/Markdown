---
title: 2019-5-3隐式, 显式, 名义和鸭子类型
date: 2019-5-3
tags: js,33,ECMAScript
categories: 前端
copyright: true
---

<font color='#000099'>js的常见内置对象：Date, Array, Math, Number, Boolean, String, Array, RegExp, Function</font>

### 类型转换

#### ECMAScript 类型转换

##### 转换成字符串

> ECMAScript 的 <font color='#66ff66'>Boolean 值、数字和字符串</font>的原始值的有趣之处在于它们是伪对象，这意味着它们实际上具有属性和方法。

- Boolean 类型的 toString() 方法只是输出 "true" 或 "false"，结果由变量的值决定

![enter description here](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1556821480960.png)

- Number 类型的 toString() 方法比较特殊，它有两种模式，即默认模式和基模式。采用默认模式，toString() 方法只是用相应的字符串输出数字值（无论是整数、浮点数还是科学计数法）

![默认模式](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1556821562124.png)

**在默认模式中，无论最初采用什么表示法声明数字，Number 类型的 toString() 方法返回的都是数字的十进制表示。因此，以八进制或十六进制字面量形式声明的数字输出的都是十进制形式的。**

![基模式](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1556821638555.png)

**采用 Number 类型的 toString() 方法的基模式，可以用不同的基输出数字，例如二进制的基是 2，八进制的基是 8，十六进制的基是 16。
基只是要转换成的基数的另一种加法而已，它是 toString() 方法的参数**

##### 转换成数字

> ECMAScript 提供了两种把非数字的原始值转换成数字的方法，即 parseInt() 【整数】和 parseFloat()【浮点数】，两个函数处理方式相似，从位置 0 开始查看每个字符，直到找到第一个非有效的字符为止，然后把该字符之前的字符串转换成整数。。

- parseInt()

- 1. parseInt() 方法首先查看位置 0 处的字符，判断它是否是个有效数字；如果不是，该方法将返回 NaN，不再继续执行其他操作。但如果该字符是有效数字，该方法将查看位置 1 处的字符，进行同样的测试。这一过程将持续到发现非有效数字的字符为止，此时 parseInt() 将把该字符之前的字符串转换成数字。

![parseInt默认模式](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1556821874471.png)

- 2. parseInt() 方法还有基模式，可以把二进制、八进制、十六进制或其他任何进制的字符串转换成整数。基是由 parseInt() 方法的第二个参数指定的

![parseInt基模式](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1556821922395.png)

- parseFloat()

- 1. 第一个出现的小数点是有效字符。如果有两个小数点，第二个小数点将被看作无效的。parseFloat() 会把这个小数点之前的字符转换成数字。这意味着字符串 "11.22.33" 将被解析成 11.22。
- 2. 字符串必须以十进制形式表示浮点数，而不是用八进制或十六进制。该方法会忽略前导 0，所以八进制数 0102 将被解析为 102。对于十六进制数 0xA，该方法将返回 NaN，因为在浮点数中，x 不是有效字符。（注释：经测试，具体的浏览器实现会返回 0，而不是 NaN。）
- 3. parseFloat() 方法也没有基模式。

![parseFloat()](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1556822401467.png)

##### 强制类型转换(type casting）

- Boolean(value) - 把给定的值转换成 Boolean 型；
- Number(value) - 把给定的值转换成数字（可以是整数或浮点数）；
- String(value) - 把给定的值转换成字符串；

3.1 Boolean() 函数

![Boolean()](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1556822855559.png)

3.2 Number() 函数

![Number()](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1556822802664.png)

3.3 String() 函数

![String()](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1556822891584.png)

**强制转换成字符串和调用 toString() 方法的唯一不同之处在于，对 null 和 undefined 值强制类型转换可以生成字符串而不引发错误**

#### 隐式类型转换，js为弱类型语言

##### 三种隐式类型转换类型

[from](https://justjavac.com/javascript/2013/04/08/javascript-quirk-1-implicit-conversion-of-values.html)

1. 隐式转换为布尔：“truthy”和“falsy”

> 被转换成 ‘false’ 的值我们成之为 falsy，被转换成 ‘true’ 的值我们成之为 truthy。

1.1 转换为**false**的原始类型

- undefined, null
- Boolean: false
- Number: -0, +0, NaNString: ‘’

1.2 除了上面的false，其余都为true

2 字符串的隐式转换

> 在 Web 开发中，我们经常得到字符串值，实际上我们期望的却是数字或者布尔值。 例如，用户输入的表单中的数据。 如果你忘了对这些字符串进行显式的转换，那么 JavaScript 会令你感到惊讶，主要体现在两个方面：

- 首先，系统不会有任何警告。
- 其次，这些值将被自动转换，但确实错误的。

![第一个栗子](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1556885094627.png)

![第二个栗子](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1556885116831.png)

![第三个栗子](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1556885139025.png)

3 对象的隐式转换

> 只有在 JavaScript 表达式或语句中需要用到数字或字符串时，对象才被隐式转换。 当需要将对象转换成数字时，需要以下三个步骤：
> - 调用 valueOf()。如果结果是原始值（不是一个对象），则将其转换为一个数字。
> - 否则，调用 toString() 方法。如果结果是原始值，则将其转换为一个数字。
> - 否则，抛出一个类型错误。

![第一步](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1556885419941.png)

![第三步](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1556886463309.png)

**如果把对象转换成字符串时，则转换操作的第一步和第二步的顺序会调换： 先尝试 toString() 进行转换，如果不是原始值，则再尝试使用 valueOf()。**

##### 三种隐式类型转换方法

[from](https://juejin.im/post/5a7172d9f265da3e3245cbca)

> 涉及隐式转换最多的两个运算符 + 和 ==。
> '+'运算符即可数字相加，也可以字符串相加。所以转换时很麻烦。'== '不同于'==='，故也存在隐式转换。- * / 这些运算符只会针对number类型，故转换的结果只能是转换成number类型。

 - 将值转为原始值，ToPrimitive()。
 - 将值转为数字，ToNumber()。
 - 将值转为字符串，ToString()。

###### 通过ToPrimitive将值转换为原始值

> js引擎内部的抽象操作ToPrimitive(input, PreferredType?),input是要转换的值，PreferredType是可选参数，可以是Number或String类型。他只是一个转换标志，转化后的结果并<font color='#ff9900'>不一定是这个参数所值的类型，但是转换结果一定是一个原始值（或者报错）。</font>

1 如果PreferredType被标记为Number，则会进行下面的操作流程来转换输入的值。

> 1. 如果输入的值已经是一个原始值，则直接返回它
> 2. 否则，如果输入的值是一个对象，则调用该对象的valueOf()方法，
   如果valueOf()方法的返回值是一个原始值，则返回这个原始值。
> 3. 否则，调用这个对象的toString()方法，如果toString()方法返回的是一个原始值，则返回这个原始值。
> 4. 否则，抛出TypeError异常。

2 如果PreferredType被标记为String，则会进行下面的操作流程来转换输入的值。

> 1. 如果输入的值已经是一个原始值，则直接返回它
> 2. 否则，调用这个对象的toString()方法，如果toString()方法返回的是一个原始值，则返回这个原始值。
> 3. 否则，如果输入的值是一个对象，则调用该对象的valueOf()方法，
   如果valueOf()方法的返回值是一个原始值，则返回这个原始值。
> 4. 否则，抛出TypeError异常。

3   如果PreferredType没有被标记

> 1. 该对象为Date类型，则PreferredType被设置为String
> 2. 否则，PreferredType被设置为Number
   
4 valueOf方法和toString方法解析

> 上面主要提及到了valueOf方法和toString方法，那这两个方法在对象里是否一定存在呢？答案是肯定的。在控制台输出Object.prototype，你会发现其中就有valueOf和toString方法，而Object.prototype是所有对象原型链顶层原型，所有对象都会继承该原型的方法，故任何对象都会有valueOf和toString方法。


----------
> <font color='#FF3030'>valueof()</font>

- Number、Boolean、String这三种构造函数生成的基础值的对象形式，通过valueOf转换后会变成相应的原始值。

![栗子](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1556887754839.png)

- Date这种特殊的对象，其原型Date.prototype上内置的valueOf函数将日期转换为<font color='#FF7F50'>日期的毫秒的形式的数值。</font>

![Data](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1556887826509.png)

- 除此之外返回的都为this，即对象本身

![this](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1556887863968.png)

----------
> <font color='#FF3030'>toString()</font>

- Number、Boolean、String、Array、Date、RegExp、Function这几种构造函数生成的对象，通过toString转换后会变成相应的字符串的形式，因为这些构造函数上封装了自己的toString方法。

![prototype](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1556888026832.png)

![toString()](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1556888078008.png)

- 除这些对象及其实例化对象之外，其他对象返回的都是该对象的类型,<font color='#FF7F50'>都是继承的Object.prototype.toString方法。</font>

![继承于Object](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1556888175822.png)

###### 通过ToNumber将值转换为数字

| 参数      | 结果                                                                             |
| --------- | -------------------------------------------------------------------------------- |
| undefined | NaN                                                                              |
| null      | +0                                                                               |
| 布尔值    | true转换1，false转换为+0                                                         |
| 数字      | 无须转换                                                                         |
| 字符串    | 有字符串解析为数字，例如：‘324’转换为324，‘qwer’转换为NaN，‘12zxc’转化为12 |
| 对象(obj) | 先进行 ToPrimitive(obj, Number)转换得到原始值，在进行ToNumber转换为数字          |

###### 通过ToString将值转换为字符串

| 参数      | 结果                                   |
| --------- | -------------------------------------- |
| undefined | 'undefined'                            |
| null      | ‘ null’                              |
| 布尔值    | 转换为'true' 或 'false'                |
| 数字      | 数字转换字符串，比如：1.765转为'1.765' |
| 字符串    | 无须转换                               |
| 对象(obj) |                                        |

![大栗子](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1556889274269.png)

> **两个对象的值进行+运算符，肯定要先进行隐式转换为原始类型才能进行计算。**
> 1、进行ToPrimitive转换，由于没有指定PreferredType类型，{}会使默认值为Number，进行ToPrimitive(input, Number)运算。
> 2、所以会执行valueOf方法，({}).valueOf(),返回的还是{}对象，不是原始值。
> 继续执行toString方法，({}).toString(),返回"[object Object]"，是原始值。

![栗子](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1556892618174.png)

>  1、首先*运算符只能对number类型进行运算，故第一步就是对{}进行ToNumber类型转换。
>  2、由于{}是对象类型，故先进行原始类型转换，ToPrimitive(input, Number)运算。
>  3、所以会执行valueOf方法，({}).valueOf(),返回的还是{}对象，不是原始值。
>  4、继续执行toString方法，({}).toString(),返回"[object Object]"，是原始值。
>  5、转换为原始值后再进行ToNumber运算，"[object Object]"就转换为NaN。
>  2 * NaN = NaN

![栗子](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1556893270149.png)

> 1、! 运算符优先级高于==，故先进行！运算。
> 2、!{}运算结果为false，结果变成 [] == false比较。
> 3、等式右边y = ToNumber(false) = 0。结果变成 [] == 0。
> 4、比较变成ToPrimitive([]) == 0。
    按照上面规则进行原始值转换，[]会先调用valueOf函数，返回this。
   不是原始值，继续调用toString方法，x = [].toString() = ''。
   故结果为 '' == 0比较。
> 5、等式左边x = ToNumber('') = 0。
>  所以结果变为： 0 == 0，返回true，比较结束。

##### ==运算符隐式转换【ES5】

![==规则](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1556893594627.png)

![栗子](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1556893682570.png)

> 1、当执行a == 1 && a == 2 && a == 3 时，会从左到右一步一步解析，首先 a == 1，会进行上面第9步转换。ToPrimitive(a， Number) == 1。
> 2、ToPrimitive(a, Number)，按照上面原始类型转换规则，会先调用valueOf方法，a的valueOf方法继承自Object.prototype。返回a本身，而非原始类型，故会调用toString方法。
> 3、因为toString被重写，所以会调用重写的toString方法，故返回1，注意这里是i++，而不是++i，它会先返回i，在将i+1。故ToPrimitive(a, Number) = 1。也就是1 == 1，此时i = 1 + 1 = 2。
> 4、执行完a == 1返回true，会执行a == 2，同理，会调用ToPrimitive(a, Number)，同上先调用valueOf方法，在调用toString方法，由于第一步，i = 2此时，ToPrimitive(a, Number) = 2， 也就是2 == 2, 此时i = 2 + 1。
> 5、同上可以推导 a == 3也返回true。故最终结果 a == 1 && a == 2 && a == 3返回true

<font color='#FF7F50'>准确检测NaN：</font>
![准确检测NaN](https://www.github.com/Merlynr/Markdown/raw/noteImg/小书匠/1558803605570.png)
<font color='#FF7F50'></font>